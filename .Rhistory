#   for(hotspot in 1:numHotspots){
#     hotspot.xBound <- runif(x.range) + x.min
#     hotspot.yBound <- runif(y.range) + y.min
#     nObs.half_life <- round(numObservationLocations/(3*hotspot))
#
#     hotspot.observations <- nObs.half_life
#     df <- data.frame(
#       x=runif(hotspot.observations, hotspot.xBound-(x.range/100), hotspot.xBound+(x.range/100)),
#       y=runif(hotspot.observations, hotspot.yBound-(y.range/100), hotspot.yBound+(y.range/100))
#       # occ_prob=rbeta(hotspot.observations, occ.beta.1, occ.beta.2),
#       # det_prob=rbeta(hotspot.observations, det.beta.1, det.beta.2)
#     )
#     coordinates(df) <- c('x', 'y')
#     crs(df) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
#     m_df <- data.frame(coordinates(df), extract(simu, df))
#     hotspot_df <- rbind(hotspot_df, m_df)
#     totObservations <- totObservations + hotspot.observations
#   }
# }
######
random.observations <- numObservationLocations - totObservations
pts <- data.frame(spsample(sp_region, numObservationLocations, type="random")@coords)
coordinates(pts) <- c('x', 'y')
crs(pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
pts_proj <- spTransform(pts, CRSobj=crs(OR.env))
pts_df.env <- data.frame(
x=pts$x,
y=pts$y,
x_proj=pts_proj$x,
y_proj=pts_proj$y,
# checklist_id=cids,
raster::extract(OR.env, pts_proj)
)
final_df <- rbind(pts_df.env, hotspot_df)
# final_norm_df <- prep_syn_df(final_df, det.df)
final_df.det <- attach_det_vars(final_df, det.df, det_covs)
# normalizing all variables besides lat/long
# (environmental & detection)
df_norm.det <- data.frame(
longitude=final_df.det$x,
latitude=final_df.det$y,
longitude_proj=final_df.det$x_proj,
latitude_proj=final_df.det$y_proj,
# site=final_df.det$site,
# checklist_id=final_df.det$checklist_id,
# locality_id=paste(as.character(df$lon), as.character(df$lat), sep = "_"),
base::scale(subset(final_df.det, select=-c(x, y, x_proj, y_proj)))
)
return(df_norm.det)
}
addOcc.Det.probs <- function(df,
true_det_coeff,
true_occ_coeff,
det_covs=c("day_of_year", "time_observations_started", "duration_minutes", "effort_distance_km", "number_observers"),
site_covs=c("TCB", "TCG", "TCW", "TCA")){
# print("here")
print(true_det_coeff)
df$det_prob <- true_det_coeff[1] +
df[[det_covs[1]]] * true_det_coeff[2] +
df[[det_covs[2]]] * true_det_coeff[3] +
df[[det_covs[3]]] * true_det_coeff[4] +
df[[det_covs[4]]] * true_det_coeff[5] +
df[[det_covs[5]]] * true_det_coeff[6]
df$det_prob <- expit(as.double(df$det_prob))
df$occ_prob <- true_occ_coeff[1] +
df[[site_covs[1]]] * true_occ_coeff[2] +
df[[site_covs[2]]] * true_occ_coeff[3] +
df[[site_covs[3]]] * true_occ_coeff[4] +
df[[site_covs[4]]] * true_occ_coeff[5] # +
# df[[site_covs[5]]] * true_occ_coeff[[6]]
df$occ_prob <- expit(as.double(df$occ_prob))
return(df)
}
# shiny app
library(shiny)
OR.init <- stack("../occ and grouping checklists/TassledCapOR/OR_tasscap_summer_2011_cropped.tif")
names(OR.init) <- c("TCB", "TCG", "TCW", "TCA")
sampling_region <- readRDS("../occ and grouping checklists/TassledCapOR/sampling_region")
det_df <- read.delim("~/Documents/Oregon State/Research/ICB General/data generation/2017_UPDATED_COVS_df.csv", header=TRUE, sep = ",")
runApp()
#
# This is the user-interface definition of a Shiny web application. You can
# run the application by clicking 'Run App' above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
library(shiny)
library(sp)
library(sf)
runApp()
runApp()
plot(oregon)
us <- raster::getData('GADM', country = 'US', level = 1)
oregon <- us[us$NAME_1 == "Oregon",]
plot(oregon)
runApp()
runApp()
names(OR.init)
runApp()
runApp()
runApp()
runApp()
?updateActionButton
runApp()
?actionButton
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
plot(samp_reg)
plot(spsample(sp_region, 100, type="clustered")@coords)
plot(spsample(samp_reg, 100, type="clustered")@coords)
plot(samp_reg)
points(spsample(samp_reg, 100, type="clustered")@coords)
points(spsample(samp_reg, 100, type="clustered")@coords)
########
# Synthetic Species Generator
########
setwd("~/Documents/Oregon State/Research/eBird/synSpecGenApp/")
source("helper.R")
source("../occ and grouping checklists/occ-cluster/run experiments/adversarial/syn_helper.R")
############
# QUESTIONS
############
# 1. is the number of sites (svs) something we can control?
#     maybe that's the benefit of this tool... it creates a GT dataset?
# 2. TODO: draw a diagram of each of these params to understand
#    the way they interact/conflict
# 3. TODO: environmental variables ... points closer are often more similar
#    and this determines det/occ probabilities
genSpecies <- function(
detectionProbability=-1,
occupiedProbability=-1,
homogeneity=-1,
isFragmented=-1,
numObservationLocations=-1,
numObservations=-1,
observationDistribution=-1,
numHotspots=-1,
envVars=-1,
det_covs=c("day_of_year", "time_observations_started", "duration_minutes", "effort_distance_km", "number_observers"),
site_covs=c("TCB", "TCG", "TCW", "TCA"),
OR.env,
sp_region,
det.df
){
# adding checklists around the specified number of hotspots
hotspot_df <- data.frame(
x=c(),
y=c(),
# TCA=c(),
# TCB=c(),
# TCW=c(),
# TCG=c()
)
totObservations <- 0
######
if(numHotspots > 0){
for(hotspot in 1:numHotspots){
nObs.half_life <- round(numObservationLocations/(3*hotspot))
hotspot.observations <- nObs.half_life
hotspot.pts <- data.frame(spsample(sp_region, hotspot.observations, type="clustered")@coords)
coordinates(hotspot.pts) <- c('x', 'y')
crs(hotspot.pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
hotspot_df <- rbind(hotspot_df, hotspot.pts)
totObservations <- totObservations + hotspot.observations
}
}
######
random.observations <- numObservationLocations - totObservations
pts <- data.frame(spsample(sp_region, random.observations, type="random")@coords)
coordinates(pts) <- c('x', 'y')
crs(pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
all_pts <- rbind(pts, hotspot_df)
pts_proj <- spTransform(all_pts, CRSobj=crs(OR.env))
final_df <- data.frame(
x=all_pts$x,
y=all_pts$y,
# x_proj=pts_proj$x,
# y_proj=pts_proj$y,
# checklist_id=cids,
raster::extract(OR.env, pts_proj)
)
# final_df <- rbind(pts_df.env, hotspot_df)
# final_norm_df <- prep_syn_df(final_df, det.df)
final_df.det <- attach_det_vars(final_df, det.df, det_covs)
# normalizing all variables besides lat/long
# (environmental & detection)
df_norm.det <- data.frame(
longitude=final_df.det$x,
latitude=final_df.det$y,
base::scale(subset(final_df.det, select=-c(x, y)))
)
return(df_norm.det)
}
addOcc.Det.probs <- function(df,
true_det_coeff,
true_occ_coeff,
det_covs=c("day_of_year", "time_observations_started", "duration_minutes", "effort_distance_km", "number_observers"),
site_covs=c("TCB", "TCG", "TCW", "TCA")){
# print("here")
print(true_det_coeff)
df$det_prob <- true_det_coeff[1] +
df[[det_covs[1]]] * true_det_coeff[2] +
df[[det_covs[2]]] * true_det_coeff[3] +
df[[det_covs[3]]] * true_det_coeff[4] +
df[[det_covs[4]]] * true_det_coeff[5] +
df[[det_covs[5]]] * true_det_coeff[6]
df$det_prob <- expit(as.double(df$det_prob))
print(true_occ_coeff)
df$occ_prob <- true_occ_coeff[1] +
df[[site_covs[1]]] * true_occ_coeff[2] +
df[[site_covs[2]]] * true_occ_coeff[3] +
df[[site_covs[3]]] * true_occ_coeff[4] +
df[[site_covs[4]]] * true_occ_coeff[5] # +
# df[[site_covs[5]]] * true_occ_coeff[[6]]
df$occ_prob <- expit(as.double(df$occ_prob))
return(df)
}
runApp()
########
# Synthetic Species Generator
########
setwd("~/Documents/Oregon State/Research/eBird/synSpecGenApp/")
source("helper.R")
source("../occ and grouping checklists/occ-cluster/run experiments/adversarial/syn_helper.R")
############
# QUESTIONS
############
# 1. is the number of sites (svs) something we can control?
#     maybe that's the benefit of this tool... it creates a GT dataset?
# 2. TODO: draw a diagram of each of these params to understand
#    the way they interact/conflict
# 3. TODO: environmental variables ... points closer are often more similar
#    and this determines det/occ probabilities
genSpecies <- function(
detectionProbability=-1,
occupiedProbability=-1,
homogeneity=-1,
isFragmented=-1,
numObservationLocations=-1,
numObservations=-1,
observationDistribution=-1,
numHotspots=-1,
envVars=-1,
det_covs=c("day_of_year", "time_observations_started", "duration_minutes", "effort_distance_km", "number_observers"),
site_covs=c("TCB", "TCG", "TCW", "TCA"),
OR.env,
sp_region,
det.df
){
# adding checklists around the specified number of hotspots
hotspot_df <- data.frame(
x=c(),
y=c()
# TCA=c(),
# TCB=c(),
# TCW=c(),
# TCG=c()
)
totObservations <- 0
######
if(numHotspots > 0){
for(hotspot in 1:numHotspots){
nObs.half_life <- round(numObservationLocations/(3*hotspot))
hotspot.observations <- nObs.half_life
hotspot.pts <- data.frame(spsample(sp_region, hotspot.observations, type="clustered")@coords)
coordinates(hotspot.pts) <- c('x', 'y')
crs(hotspot.pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
hotspot_df <- rbind(hotspot_df, hotspot.pts)
totObservations <- totObservations + hotspot.observations
}
}
######
random.observations <- numObservationLocations - totObservations
pts <- data.frame(spsample(sp_region, random.observations, type="random")@coords)
coordinates(pts) <- c('x', 'y')
crs(pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
all_pts <- rbind(pts, hotspot_df)
pts_proj <- spTransform(all_pts, CRSobj=crs(OR.env))
final_df <- data.frame(
x=all_pts$x,
y=all_pts$y,
# x_proj=pts_proj$x,
# y_proj=pts_proj$y,
# checklist_id=cids,
raster::extract(OR.env, pts_proj)
)
# final_df <- rbind(pts_df.env, hotspot_df)
# final_norm_df <- prep_syn_df(final_df, det.df)
final_df.det <- attach_det_vars(final_df, det.df, det_covs)
# normalizing all variables besides lat/long
# (environmental & detection)
df_norm.det <- data.frame(
longitude=final_df.det$x,
latitude=final_df.det$y,
base::scale(subset(final_df.det, select=-c(x, y)))
)
return(df_norm.det)
}
addOcc.Det.probs <- function(df,
true_det_coeff,
true_occ_coeff,
det_covs=c("day_of_year", "time_observations_started", "duration_minutes", "effort_distance_km", "number_observers"),
site_covs=c("TCB", "TCG", "TCW", "TCA")){
# print("here")
print(true_det_coeff)
df$det_prob <- true_det_coeff[1] +
df[[det_covs[1]]] * true_det_coeff[2] +
df[[det_covs[2]]] * true_det_coeff[3] +
df[[det_covs[3]]] * true_det_coeff[4] +
df[[det_covs[4]]] * true_det_coeff[5] +
df[[det_covs[5]]] * true_det_coeff[6]
df$det_prob <- expit(as.double(df$det_prob))
print(true_occ_coeff)
df$occ_prob <- true_occ_coeff[1] +
df[[site_covs[1]]] * true_occ_coeff[2] +
df[[site_covs[2]]] * true_occ_coeff[3] +
df[[site_covs[3]]] * true_occ_coeff[4] +
df[[site_covs[4]]] * true_occ_coeff[5] # +
# df[[site_covs[5]]] * true_occ_coeff[[6]]
df$occ_prob <- expit(as.double(df$occ_prob))
return(df)
}
runApp()
# adding checklists around the specified number of hotspots
hotspot_df <- data.frame(
x=c(),
y=c()
# TCA=c(),
# TCB=c(),
# TCW=c(),
# TCG=c()
)
totObservations <- 0
numHotspots <- 2
hotspot <- 1
numObservationLocations <- 200
n.hotspot.observations <- round(numObservationLocations/(3*hotspot))
n.hotspot.observations
hotspot.pts <- data.frame(spsample(sp_region, n.hotspot.observations, type="clustered")@coords)
sp_region <- samp_reg
hotspot.pts <- data.frame(spsample(sp_region, n.hotspot.observations, type="clustered")@coords)
coordinates(hotspot.pts) <- c('x', 'y')
hotspot.pts
random.observations <- numObservationLocations - totObservations
pts <- data.frame(spsample(sp_region, random.observations, type="random")@coords)
pts
############
# QUESTIONS
############
# 1. is the number of sites (svs) something we can control?
#     maybe that's the benefit of this tool... it creates a GT dataset?
# 2. TODO: draw a diagram of each of these params to understand
#    the way they interact/conflict
# 3. TODO: environmental variables ... points closer are often more similar
#    and this determines det/occ probabilities
genSpecies <- function(
detectionProbability=-1,
occupiedProbability=-1,
homogeneity=-1,
isFragmented=-1,
numObservationLocations=-1,
numObservations=-1,
observationDistribution=-1,
numHotspots=-1,
envVars=-1,
det_covs=c("day_of_year", "time_observations_started", "duration_minutes", "effort_distance_km", "number_observers"),
site_covs=c("TCB", "TCG", "TCW", "TCA"),
OR.env,
sp_region,
det.df
){
# adding checklists around the specified number of hotspots
hotspot_df <- data.frame(
x=c(),
y=c()
# TCA=c(),
# TCB=c(),
# TCW=c(),
# TCG=c()
)
totObservations <- 0
######
if(numHotspots > 0){
for(hotspot in 1:numHotspots){
n.hotspot.observations <- round(numObservationLocations/(3*hotspot))
# hotspot.observations <- nObs.half_life
hotspot.pts <- data.frame(spsample(sp_region, n.hotspot.observations, type="clustered")@coords)
names(hotspot.pts) <- c('x', 'y')
coordinates(hotspot.pts) <- c('x', 'y')
crs(hotspot.pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
hotspot_df <- rbind(hotspot_df, hotspot.pts)
totObservations <- totObservations + n.hotspot.observations
}
}
######
random.observations <- numObservationLocations - totObservations
pts <- data.frame(spsample(sp_region, random.observations, type="random")@coords)
coordinates(pts) <- c('x', 'y')
crs(pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
all_pts <- rbind(pts, hotspot_df)
pts_proj <- spTransform(all_pts, CRSobj=crs(OR.env))
final_df <- data.frame(
x=all_pts$x,
y=all_pts$y,
# x_proj=pts_proj$x,
# y_proj=pts_proj$y,
# checklist_id=cids,
raster::extract(OR.env, pts_proj)
)
# final_df <- rbind(pts_df.env, hotspot_df)
# final_norm_df <- prep_syn_df(final_df, det.df)
final_df.det <- attach_det_vars(final_df, det.df, det_covs)
# normalizing all variables besides lat/long
# (environmental & detection)
df_norm.det <- data.frame(
longitude=final_df.det$x,
latitude=final_df.det$y,
base::scale(subset(final_df.det, select=-c(x, y)))
)
return(df_norm.det)
}
runApp()
n.hotspot.observations <- round(numObservationLocations/(3*hotspot))
hotspot.pts <- data.frame(spsample(sp_region, n.hotspot.observations, type="clustered")@coords)
names(hotspot.pts) <- c('x', 'y')
coordinates(hotspot.pts) <- c('x', 'y')
crs(hotspot.pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
hotspot_df <- rbind(hotspot_df, hotspot.pts)
hotspot_df
hotspot.pts
############
# QUESTIONS
############
# 1. is the number of sites (svs) something we can control?
#     maybe that's the benefit of this tool... it creates a GT dataset?
# 2. TODO: draw a diagram of each of these params to understand
#    the way they interact/conflict
# 3. TODO: environmental variables ... points closer are often more similar
#    and this determines det/occ probabilities
genSpecies <- function(
detectionProbability=-1,
occupiedProbability=-1,
homogeneity=-1,
isFragmented=-1,
numObservationLocations=-1,
numObservations=-1,
observationDistribution=-1,
numHotspots=-1,
envVars=-1,
det_covs=c("day_of_year", "time_observations_started", "duration_minutes", "effort_distance_km", "number_observers"),
site_covs=c("TCB", "TCG", "TCW", "TCA"),
OR.env,
sp_region,
det.df
){
# adding checklists around the specified number of hotspots
totObservations <- 0
######
if(numHotspots > 0){
for(hotspot in 1:numHotspots){
n.hotspot.observations <- round(numObservationLocations/(3*hotspot))
# hotspot.observations <- nObs.half_life
hotspot.pts <- data.frame(spsample(sp_region, n.hotspot.observations, type="clustered")@coords)
names(hotspot.pts) <- c('x', 'y')
coordinates(hotspot.pts) <- c('x', 'y')
crs(hotspot.pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
if(hotspot == 1){
hotspot_df <- hotspot.pts
} else {
hotspot_df <- rbind(hotspot_df, hotspot.pts)
}
totObservations <- totObservations + n.hotspot.observations
}
}
######
random.observations <- numObservationLocations - totObservations
pts <- data.frame(spsample(sp_region, random.observations, type="random")@coords)
coordinates(pts) <- c('x', 'y')
crs(pts) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
all_pts <- rbind(pts, hotspot_df)
pts_proj <- spTransform(all_pts, CRSobj=crs(OR.env))
final_df <- data.frame(
x=all_pts$x,
y=all_pts$y,
# x_proj=pts_proj$x,
# y_proj=pts_proj$y,
# checklist_id=cids,
raster::extract(OR.env, pts_proj)
)
# final_df <- rbind(pts_df.env, hotspot_df)
# final_norm_df <- prep_syn_df(final_df, det.df)
final_df.det <- attach_det_vars(final_df, det.df, det_covs)
# normalizing all variables besides lat/long
# (environmental & detection)
df_norm.det <- data.frame(
longitude=final_df.det$x,
latitude=final_df.det$y,
base::scale(subset(final_df.det, select=-c(x, y)))
)
return(df_norm.det)
}
runApp()
